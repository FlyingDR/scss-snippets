$font-files: () !default;
$font-families: () !default;
$font-sizes: () !default;
$font-file-formats: (
    eot: embedded-opentype,
    woff: woff,
    woff2: woff2,
    ttf: truetype,
    svg: svg,
) !default;
$font-default-formats: woff ttf eot svg !default;
$font-default-properties: (
    font-weight: normal,
    font-style: normal,
) !default;
$font-url-prefix: '' !default;
$font-handlers: (
    parse: (
        font-property-parser-font-family,
        font-property-parser-font-size,
        font-property-parser-font-weight,
        font-property-parser-font-style,
        font-property-parser-color,
        font-property-parser-line-height,
        font-property-parser-line-height,
        font-property-parser-letter-spacing,
        font-property-parser-white-space,
        font-property-parser-text-transform,
    ),
    normalize: (
        font-property-normalizer-line-height,
        font-property-normalizer-important,
    ),
) !default;

// Add custom handler for font properties. Various types of handlers are accepted, determined by $type argument:
// - parse          Handler should accept (mixed $value, map $properties, map $options) arguments 
//                  and return null if no result is available or ($property: $value) map of properties
// - normalize      Handler should accept (map $properties, map $options) and return new font properties map
// 
// @param string $handler           Handler function name
// @param string $type              Handler type (parse, normalize)
// @param string|boolean $after     Handler name to insert given handler after, true to set handler at last position, false to set handler at first position 
@mixin font-add-handler($handler, $type: parse, $after: true) {
    @if (not function-exists($handler)) {
        @error 'Unavailable font properties handler: #{$handler}';
    }
    @if (not map-has-key($font-handlers, $type)) {
        @error 'Invalid font properties handler type: #{$type}';
    }
    $result: ();
    @if ($after == false) {
        $result: append($result, $handler);
    }
    @each $current-handler in map-get($font-handlers, $type) {
        $result: append($result, $current-handler);
        @if ($current-handler == $after) {
            $result: append($result, $handler);
        }
    }
    @if ($after == true) {
        $result: append($result, $handler);
    }
    $font-handlers: map-merge($font-handlers, ($type: $result)) !global;
}

// Remove custom font properties parser handler
// 
// @param string $handler   Handler function name to remove
@mixin font-remove-handler($handler) {
    $handlers: ();
    @each $type, $fh in $font-handlers {
        $nfh: ();
        @each $h in $fh {
            @if ($h != $handler) {
                $nfh: append($nfh, $h);
            }
        }
        $handlers: map-merge($handlers, ($type: $nfh));
    }
    $font-handlers: $handlers !global;
}

// Replace custom font properties parser handler with new handler
// 
// @param string $handler-to-replace    Handler function name to replace
// @param string $new-handler           Handler function name to set instead $handler-to-replace
@mixin font-replace-handler($handler-to-replace, $new-handler) {
    $handlers: ();
    @each $type, $fh in $font-handlers {
        $nfh: ();
        @each $h in $fh {
            @if ($h == $handler-to-replace) {
                $nfh: append($nfh, $new-handler);
            } @else {
                $nfh: append($nfh, $h);
            }
        }
        $handlers: map-merge($handlers, ($type: $nfh));
    }
    $font-handlers: $handlers !global;
}

@function font-property-parser-font-family($value, $properties, $options) {
    @if (map-has-key($properties, font-family)) {
        @return null;
    }
    @if (map-has-key($font-families, $value)) {
        @return (font-family: join(map-get($font-families, $value), (), comma));
    }
    @return null;
}

@function font-property-parser-font-size($value, $properties, $options) {
    @if (map-has-key($properties, font-size)) {
        @return null;
    }
    $named-font-sizes: xx-small, x-small, small, medium, large, x-large, xx-large, larger, smaller;
    $font-size-units: px, em, rem, vw, vh, vmin, vmax;
    $is-responsive: function-exists(is-responsive) and is-responsive();
    $r-size-exists: false;
    $r-fs-key: 'font-sizes/' + $value;
    $resolve: not map-has-key($options, skip-font-size-resolve);
    @if ($is-responsive and not $resolve) {
        @each $id in responsive-get-ids() {
            @if (not $r-size-exists) {
                @if (r-has($r-fs-key, $id)) {
                    $r-size-exists: true;
                }
            }
        }
    }
    $result: null;
    @if ($is-responsive and $resolve and r-has($r-fs-key)) {
        $result: r-get($r-fs-key);
    } @else if ($is-responsive and $r-size-exists) {
        $result: $value;
    } @else if (index($named-font-sizes, $value)) {
        $result: $value;
    } @else if (map-has-key($font-sizes, $value)) {
        $result: map-get($font-sizes, $value);
    } @else if ((type-of($value) == number) and index($font-size-units, unit($value))) {
        $result: $value;
    }
    @if ($result == null) {
        @return null;
    }
    @if (type-of($result) == number and index(px rem, unit($result))) {
        $result: v($result);
    }
    @if (not $resolve) {
        $resolve: $value;
    }
    @return (font-size: $result);
}

@function font-property-parser-font-weight($value, $properties, $options) {
    @if (map-has-key($properties, font-weight)) {
        @return null;
    }
    $weights: normal, bold, bolder, lighter, 100, 200, 300, 400, 500, 600, 700, 800, 900;
    @if (index($weights, $value)) {
        @return (font-weight: $value);
    }
    @return null;
}

@function font-property-parser-font-style($value, $properties, $options) {
    @if (map-has-key($properties, font-style)) {
        @return null;
    }
    $styles: normal, italic, oblique;
    @if (index($styles, $value)) {
        @return (font-style: $value);
    }
    @return null;
}

@function font-property-parser-color($value, $properties, $options) {
    @if (map-has-key($properties, color)) {
        @return null;
    }
    @if (type-of($value) == color) {
        @return (color: $value);
    }
    @return null;
}

@function font-property-parser-line-height($value, $properties, $options) {
    @if (map-has-key($properties, line-height)) {
        @return null;
    }
    @if ((type-of($value) == number) and not ((unit($value) == em) and (abs($value) <= 0.5))) {
        @return (line-height: $value);
    } @else if (type-of($value) == '' and str-index('' + $value, '/') != null) {
        $value: unquote('' + $value);
        $a: to-number(str-slice($value, 1, str-index($value, '/') - 1));
        $b: to-number(str-slice($value, str-index($value, '/') + 1));
        @return (line-height: $a / $b);
    }
    @return null;
}

@function font-property-parser-letter-spacing($value, $properties, $options) {
    @if (map-has-key($properties, letter-spacing)) {
        @return null;
    }
    $letter-spacing-units: px, em, rem;
    @if (type-of($value) == number and index($letter-spacing-units, unit($value))) {
        @return (letter-spacing: $value);
    }
    @return null;
}

@function font-property-parser-white-space($value, $properties, $options) {
    @if (map-has-key($properties, white-space)) {
        @return null;
    }
    $whitespace: normal, pre, nowrap, pre-wrap, pre-line;
    @if (index($whitespace, $value)) {
        @return (white-space: $value);
    }
    @return null;
}

@function font-property-parser-text-transform($value, $properties, $options) {
    @if (map-has-key($properties, text-transform)) {
        @return null;
    }
    $transform: none, capitalize, uppercase, lowercase, full-width;
    @if (index($transform, $value)) {
        @return (text-transform: $value);
    }
    @return null;
}

@function font-property-normalizer-line-height($properties, $options) {
    @if (map-has-key($properties, font-size) and map-has-key($properties, line-height)) {
        $fs: map-get($properties, font-size);
        $lh: map-get($properties, line-height);
        @if ((type-of($fs) == number) and (type-of($lh) == number) and (unit($fs) == unit($lh))) {
            $properties: map-merge($properties, (line-height: strip-units($lh / $fs)));
        }
    }
    @return $properties;
}

@function font-property-normalizer-important($properties, $options) {
    @if (not map-has-key($options, important)) {
        @return $properties;
    }
    $important: map-get($options, important);
    @each $prop, $value in $properties {
        @if (index($important, $prop) != null) {
            $properties: map-merge($properties, ($prop: $value !important));
        }
    }
    @return $properties;
}

// Parse given font string into set of CSS properties and their values
//
// @param list $font        Font values list to parse
// @param map $options      Additional options to pass to font parsers
// @return map
// noinspection SassScssResolvedByNameOnly
@function parse-font($font, $options: null) {
    @if (type-of($font) == map) {
        // Treat map argument as "already parsed font properties"
        @return $font;
    }
    @if (type-of($options) != map) {
        $options: ();
    }
    $properties: ();
    @each $item in $font {
        $handled: false;
        @each $handler in map-get($font-handlers, parse) {
            @if (not $handled) {  
                $r: call($handler, $item, $properties, $options);
                @if (type-of($r) == map) {
                    $properties: map-merge($properties, $r);
                    $handled: true;
                }
            }
        }
    }
    @each $handler in map-get($font-handlers, normalize) {
        $r: call($handler, $properties, $options);
        @if (type-of($r) == map) {
            $properties: $r;
        }
    }
    @return $properties;
}

// Generate font CSS properties from given font string
//
// @param list|map $font      Either list of font values list to parse or already parsed list of font properties
// @param map|list $options   Map of font parsing options or list of font properties that should be marked as important
@mixin font($font, $options: null) {
    @each $prop, $value in parse-font($font, $options) {
        #{$prop}: $value;
    }
}

// Responsive version of font() mixin to render font properties based on responsive configuration information
//
// @param string $key               Responsive configuration key to take font information from, can be skipped
// @param list|map $font            Base font information to define together with information from responsive configuration
// @param map|list $options         Map of font parsing options or list of font properties that should be marked as important
//noinspection SassScssResolvedByNameOnly
@mixin r-font($key, $font: null, $options: null) {
    @if (type-of($key) != string or (type-of($key) == string and str-index($key, '/') == null)) {
        @if ($options == null and $font != null) {
            $options: $font;
        }
        $font: $key;
        $key: null;
    }
    $opt: ();
    @if (type-of($options) == map) {
        $opt: $options;
    } @else if (type-of($options) == list or type-of($options) == string) {
        $opt: (important: $options);
    }
    $options: $opt;
    $suffix: null;
    @if ($font != null) {
        $properties: parse-font($font, map-merge($options, (skip-font-size-resolve: true)));
        @if (map-has-key($properties, font-size)) {
            $suffix: map-get($properties, font-size);
            $properties: map-remove($properties, font-size);
        }
        @include font($font, $options);
        @if (length($properties) == 0) {
            $suffix: $font;
        }
    }
    @if (function-exists(is-responsive) and is-responsive()) {
        @if ($key != null) {
            @include r-each-if($key, false) {
                @include font(r-get($key), $options);
            }
        }
        @if ($suffix != null) {
            $found: false;
            $rk: 'font-sizes/' + $suffix;
            @include r-each-if($rk, false) {
                $found: true;
                @include font(r-get($rk), $options);
            }
            @if (not $found) {
                $rk: 'fonts/' + $suffix;
                @include r-each-if($rk, false) {
                    @include font(r-get($rk), $options);
                }
            }
        }
    }
}

// Register custom font to use in application
//
// @param string $id                Font Id to use in application
// @param string|list $font-names   List of font family names to use for this font e.g. (Tahoma, Helvetica, Arial, sans-serif)
// @param string|map $filename      One of:
//                                  - base file name (without extension) of font file if file is stored locally
//                                  - map ($filename: $properties)
//                                  - map: ($filename: (properties: $properties, formats: $formats))
// @param string|list $properties   String for parse-font() or list of additional font CSS properties to put in @font-face definition, e.g. (font-weight: bold), defaults to $font-default-properties
// @param list $formats             List of file formats for locally stored font file, defaults to $font-default-formats
@mixin register-font($id, $font-names, $filename: null, $properties: null, $formats: null) {
    @if (type-of($font-names) != list) {
        $font-names: ($font-names);
    }
    $font-families: map-merge($font-families, ($id: $font-names)) !global;
    @if ($filename != null) {
        $definitions: ();
        @if (type-of($filename) == string) {
            $filename: ($filename: (properties: $properties, formats: $formats));
        }
        @if ($properties == null) {
            $properties: $font-default-properties;
        } @else if (type-of($properties) == list) {
            $properties: parse-font($properties);
        }
        @if ($formats == null) {
            $formats: $font-default-formats;
        }
        @each $fname, $fdef in $filename {
            $fprop: null;
            $fformats: null;
            @if (type-of($fdef) == string) {
                $fprop: $fdef;
            } @else if (type-of($fdef) == list) {
                @if ((length($fdef) == 2) and (type-of(nth($fdef, 2)) == map)) {
                    // This is list of properties and formats
                    $fprop: nth($fdef, 1);
                    $fformats: nth($fdef, 2);
                } @else {
                    // This is list of properties
                    $fprop: $fdef;
                }
            } @else if (type-of($fdef) == map) {
                @if (map-has-key($fdef, properties)) {
                    $fprop: map-get($fdef, properties);
                }
                @if (map-has-key($fdef, formats)) {
                    $fformats: map-get($fdef, formats);
                }
            }
            $definitions: map-merge($definitions, ($fname: (properties: $fprop, formats: $fformats)));
        }
        @each $fname, $fdef in $definitions {
            $fprop: map-get($fdef, properties);
            $fformats: map-get($fdef, formats);
            @if ($fprop == null) {
                $fprop: $properties;
            } @else if (type-of($fprop) == list) {
                $fprop: parse-font($fprop);
            }
            @if ($fformats == null) {
                $fformats: $formats;
            }
            $font-files: map-merge($font-files, ($fname: (name: nth($font-names, 1), formats: $fformats, properties: $fprop))) !global;
        }
    }
}

// Register named font size
//
// @param string|map $name  Either font size name or map of font sizes to register
// @param mixed $size       Font size to register (in a case if $name is a string)
@mixin register-font-size($name, $size: null) {
    $sizes: ();
    @if (type-of($name) == 'map') {
        $sizes: $name;
    } @else {
        $sizes: ($name: $size);
    }
    $font-sizes: map-merge($font-sizes, $sizes) !global;
}

@if (not function-exists(font-url)) {
    @function font-url($path) {
        $url: $font-url-prefix;
        @if (($url != '') and str_slice($url, -1) != '/') {
            $url: $url + '/';
        }
        @return unquote("url('#{$url + $path}')");
    }
}

// Render registered font faces definition
//
// @param map $fonts    Fonts definition to render
@mixin font-files($fonts: $font-files) {
    @each $filename, $info in $font-files {
        $formats: map-get($info, formats);
        @font-face {
            font-family: map-get($info, name);
            @if (index($formats, eot) != null) {
                //noinspection CssInvalidFunction
                src: font-url('#{$filename}.eot');
            }
            $sources: ();
            @if (index($formats, eot) != null) {
                $ff: map-get($font-file-formats, eot);
                //noinspection CssInvalidFunction
                $sources: append($sources, font-url('#{$filename}.eot?#iefix') format('#{$ff}'));
            }
            @each $extension in $formats {
                @if ($extension != eot) {
                    $ff: map-get($font-file-formats, $extension);
                    //noinspection CssInvalidFunction
                    $sources: append($sources, font-url('#{$filename}.#{$extension}') format('#{$ff}'));
                }
            }
            src: join($sources, (), comma);
            @each $prop, $value in map-get($info, properties) {
                #{$prop}: $value;
            }
        }
    }
}
